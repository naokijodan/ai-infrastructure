{
  "name": "LINE Bot Webhook",
  "description": null,
  "active": true,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "line-bot",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "Webhook_1",
      "name": "LineWebhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [
        200,
        300
      ]
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {
          "responseCode": 200
        }
      },
      "id": "Respond_1",
      "name": "Respond OK",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        520,
        180
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "language": "javaScript",
        "jsCode": "const items = $input.all();\n\n// LINE webhook payload example:\n// { events: [ { type, replyToken, message: { type: 'text', text }, ... } ] }\n\nfunction normalizeText(t) {\n  if (!t) return '';\n  return String(t).trim();\n}\n\nfunction mapTemplateFromText(text) {\n  const t = normalizeText(text);\n  const lower = t.toLowerCase();\n  if (t === '市場チェック' || lower === 'market') return 'market-check';\n  if (t === 'リサーチ' || lower === 'research') return 'resale-research';\n  if (t === '議論' || lower === 'discuss') return 'ai-discussion';\n  if (t === '時計' || lower === 'watch') return 'watch-data-add';\n  return null;\n}\n\nconst out = [];\nfor (const item of items) {\n  const body = item.json?.body ?? item.json;\n  const events = Array.isArray(body?.events) ? body.events : [];\n  const messageEvent = events.find(e => e && e.type === 'message' && e.message && e.message.type === 'text');\n\n  if (!messageEvent) {\n    // No message event; still produce a safe output to avoid breaking the flow\n    out.push({ json: { replyToken: body?.events?.[0]?.replyToken || '', template: null, originalText: '' } });\n    continue;\n  }\n\n  const replyToken = messageEvent.replyToken || '';\n  const originalText = normalizeText(messageEvent.message?.text || '');\n  const template = mapTemplateFromText(originalText);\n\n  out.push({ json: { replyToken, template, originalText } });\n}\n\nreturn out;"
      },
      "id": "Code_Parse_1",
      "name": "Parse LINE Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        520,
        420
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "language": "javaScript",
        "jsCode": "const http = require(\"http\");\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const { template, originalText, replyToken } = item.json;\n\n  const body = JSON.stringify(\n    template\n      ? { template, timeout: 300000 }\n      : { prompt: originalText || \"hello\", timeout: 300000 }\n  );\n\n  let resultText = \"\";\n  try {\n    const response = await new Promise((resolve, reject) => {\n      const req = http.request({\n        hostname: \"127.0.0.1\",\n        port: 3456,\n        path: \"/execute\",\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"Content-Length\": Buffer.byteLength(body)\n        }\n      }, (res) => {\n        let data = \"\";\n        res.on(\"data\", chunk => data += chunk);\n        res.on(\"end\", () => resolve({ status: res.statusCode, body: data }));\n      });\n      req.on(\"error\", reject);\n      req.setTimeout(300000, () => { req.destroy(); reject(new Error(\"Timeout\")); });\n      req.write(body);\n      req.end();\n    });\n\n    const parsed = JSON.parse(response.body);\n    if (response.status === 200) {\n      resultText = parsed.result;\n    } else {\n      resultText = \"Error: \" + (parsed.error || response.body);\n    }\n  } catch(e) {\n    resultText = \"Bridge error: \" + e.message;\n  }\n\n  if (resultText.length > 4800) {\n    resultText = resultText.slice(0, 4800) + \"... (truncated)\";\n  }\n  if (!resultText) resultText = \"No output\";\n  results.push({ json: { replyToken, resultText } });\n}\nreturn results;\n"
      },
      "id": "Code_Claude_1",
      "name": "Execute Claude",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        820,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "const https = require(\"https\");\nconst fs = require(\"fs\");\nconst items = $input.all();\nconst results = [];\n\nconst LINE_TOKEN = fs.readFileSync(\"/Users/naokijodan/ai-scripts/.line-channel-token\", \"utf-8\").trim();\n\nfor (const item of items) {\n  const { replyToken, resultText } = item.json;\n\n  const body = JSON.stringify({\n    replyToken: replyToken,\n    messages: [{ type: \"text\", text: resultText || \"(empty)\" }]\n  });\n\n  try {\n    const response = await new Promise((resolve, reject) => {\n      const req = https.request({\n        hostname: \"api.line.me\",\n        path: \"/v2/bot/message/reply\",\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"Authorization\": \"Bearer \" + LINE_TOKEN\n        }\n      }, (res) => {\n        let data = \"\";\n        res.on(\"data\", chunk => data += chunk);\n        res.on(\"end\", () => resolve({ status: res.statusCode, body: data }));\n      });\n      req.on(\"error\", reject);\n      req.write(body);\n      req.end();\n    });\n\n    results.push({ json: { status: response.status, body: response.body, replyToken } });\n  } catch(e) {\n    results.push({ json: { error: e.message, replyToken } });\n  }\n}\nreturn results;\n",
        "mode": "runOnceForAllItems",
        "language": "javaScript"
      },
      "id": "HTTP_Reply_1",
      "name": "Reply to LINE",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        420
      ]
    }
  ],
  "connections": {
    "Parse LINE Message": {
      "main": [
        [
          {
            "node": "Execute Claude",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Claude": {
      "main": [
        [
          {
            "node": "Reply to LINE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LineWebhook": {
      "main": [
        [
          {
            "node": "Respond OK",
            "type": "main",
            "index": 0
          },
          {
            "node": "Parse LINE Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "meta": null
}
